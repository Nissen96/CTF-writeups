---
layout: writeup
title: Alkaloid Stream
ctf: pbctf
points: 134
solves: 132
tags: 
    - crypto
date: 2021-10-11
description: |-
    I found a weird stream cipher scheme. Can you break this?
---
<details>
    <summary>tl;dr</summary>
    <p>For each input bit, a <code>key</code> number and <code>fake</code> number is generated. A random <code>keystream</code> is generated and a corresponding <code>public</code> array, such that</p>
    <p><code>public[i] = [fake[i], key[i]] if keystream[i] else [key[i], fake[i]]</code></p>
    <p>The input is XORed with the random keystream to generate the ciphertext and this is output together with <code>public</code>. But <code>fake</code> was generated by XORing values from <code>key</code>, and based on this, we can guess which values from <code>public</code> are fake. The others must be from <code>key</code>, allowing us to recover the <code>keystream</code> and decrypt the <code>flag</code>.</p>
</details>

***

## Introduction

We are given the challenge files [gen.py]({{ site.baseurl }}/assets/CTFs/2021/pbctf/gen.py) and [output.txt]({{ site.baseurl }}/assets/CTFs/2021/pbctf/output.txt). Let us first take a look at the script `gen.py`, inspecting the main functionality:
```python
from flag import flag
flag = bytes_to_bits(flag)

key = keygen(len(flag))
keystream, public = gen_keystream(key)
assert keystream == recover_keystream(key, public)
enc = bits_to_bytes(xor(flag, keystream))

print(enc.hex())
print(public)
```
The script converts the flag to bits, generates a `key` of the same length, and generates some `keystream` and `public` value. Next, it performs a check to ensure the generated `keystream` matches what you would get from `recover_keystream(key, public)`. Finally, it encrypts the `flag` by XORing with the `keystream` and then outputs the ciphertext as hex and the `public` value, whatever that is. The contents of `output.txt` matches this output and seems to be the encrypted flag followed by the corresponding `public` value.

Let's look deeper into each step, starting with `key = keygen(len(flag))`:
```python
def keygen(ln):
    # Generate a linearly independent key
    arr = [ 1 << i for i in range(ln) ]
    for i in range(ln):
        for j in range(i):
            if random.getrandbits(1):
                arr[j] ^= arr[i]
    for i in range(ln):
        for j in range(i):
            if random.getrandbits(1):
                arr[ln - 1 - j] ^= arr[ln - 1 - i]
    return arr
```
The function creates an array of `ln` powers of 2 (one per flag bit), so `[1, 2, 4, 8, ...]`, and then runs through two loops. The first iterates over the array from the beginning and XORs each number with some of the previous (determined by `random.getrandbits(1)`). The second basically does the same but from behind and in reverse order. The end result is a list of `ln` seemingly random numbers, which is the `key`.

This is used in the next step, `keystream, public = gen_keystream(key)`:
```python
def gen_keystream(key):
    ln = len(key)
    
    # Generate some fake values based on the given key...
    fake = [0] * ln
    for i in range(ln):
        for j in range(ln // 3):
            if i + j + 1 >= ln:
                break
            fake[i] ^= key[i + j + 1]

    # Generate the keystream
    res = []
    for i in range(ln):
        t = random.getrandbits(1)
        if t:
            res.append((t, [fake[i], key[i]]))
        else:
            res.append((t, [key[i], fake[i]]))

    # Shuffle!
    random.shuffle(res)

    keystream = [v[0] for v in res]
    public = [v[1] for v in res]
    return keystream, public
```
This function first generates the list `fake` by XORing some numbers from the actual `key` together and then uses this as a sort of fake key. It then generates `ln` random bits which ends up being the `keystream`. It populates `public` with both a `key` value and `fake` value for each `keystream` bit. If the bit is a 1, it inserts `[fake[i], key[i]]`, and else `[key[i], fake[i]]` - so the bit determines the order. This means `public` is a list of `ln` elements, where each element is a list of two numbers - a `key` value and `fake` value -- but without the `key` or `keystream`, there should be no way of knowing which is which. As an example, if we have
```python
    key = [12, 34, 56, 78]
    fake = [98, 76, 54, 32]  # Just example values
```
and the random `keystream` ends up being `[0, 1, 1, 0]`, then we would have
```python
    public = [
        [12, 98],  # key, fake
        [76, 34],  # fake, key
        [54, 56],  # fake, key
        [78, 32]   # key, fake
    ]
```
The `keystream` tells us which values from `public` are `key` values and `fake` values - a 0 indicates the first is a `key` value and a 1 that the second is. At the end, the function returns `keystream` and `public`.

We can recover the `keystream` from `key` and `public`. This is what `recover_keystream(key, public)` does:
```python
def recover_keystream(key, public):
    st = set(key)
    keystream = []
    for v0, v1 in public:
        if v0 in st:
            keystream.append(0)
        elif v1 in st:
            keystream.append(1)
        else:
            assert False, "Failed to recover the keystream"
    return keystream
```
This just goes through each `public` element and if the first value is somewhere in the `key`, it adds a 0 to the `keystream`, else a 1. The recovered `keystream` will only be correct if `fake` doesn't end up containing any value that is also in `key`. This is the reason why the script runs
```python
keystream, public = gen_keystream(key)
assert keystream == recover_keystream(key, public)
```
So after generating the `keystream` and `public`, it makes sure the same `keystream` would be recovered from the `key` and `public` before using it for encryption. If everything goes well, the encryption can finally be performed:
```python
enc = bits_to_bytes(xor(flag, keystream))
```
This is a simple XOR of the `flag` and `keystream`.

## Vulnerability

Since the encryption is just an XOR with a randomly generated `keystream`, we don't get much info from the encrypted flag itself. We need to find the `keystream`, and since we only have the `public` array, we must somehow be able to guess the stream from that. Said differently, if this scheme is vulnerable, it must be because we can somehow guess which values in `public` are `key` values and which are `fake`.

Looking at the `keygen()` method, there doesn't seem to be an obvious way to guess which of the values in `public` it could have generated. Instead, we look at how the `fake` values are generated from the `key`. This direct dependence and lack of inserted randomness could perhaps lead us to guess which values are fake - and therefore which are from `key`. The `fake` list is generated as follows:
```python
fake = [0] * ln
for i in range(ln):
    for j in range(ln // 3):
        if i + j + 1 >= ln:
            break
        fake[i] ^= key[i + j + 1]
```
The outer loop iterates over each position of `fake`. For each index `i`, it XORs into `fake[i]` the next `ln // 3` values from `key`, starting from `key[i + 1]`.

As an example, consider `key = [1, 2, 3, 4, 5, 6, 7, 8]`, so `ln = 8` and `ln // 3 = 2`. This means every value in `fake` is just the XOR of the two next values from `key`. We run through each iteration, showing the contents of `fake`:
```python
key = [1, 2, 3, 4, 5, 6, 7, 8]
fake = [0, 0, 0, 0, 0, 0, 0, 0]

fake = [2 ^ 3, 0, 0, 0, 0, 0, 0, 0] = [1, 0, 0, 0, 0,  0, 0, 0]  # i = 0
fake = [1, 3 ^ 4, 0, 0, 0, 0, 0, 0] = [1, 7, 0, 0, 0,  0, 0, 0]  # i = 1
fake = [1, 7, 4 ^ 5, 0, 0, 0, 0, 0] = [1, 7, 1, 0, 0,  0, 0, 0]  # i = 2
fake = [1, 7, 1, 5 ^ 6, 0, 0, 0, 0] = [1, 7, 1, 3, 0,  0, 0, 0]  # i = 3
fake = [1, 7, 1, 3, 6 ^ 7, 0, 0, 0] = [1, 7, 1, 3, 1,  0, 0, 0]  # i = 4
fake = [1, 7, 1, 3, 1, 7 ^ 8, 0, 0] = [1, 7, 1, 3, 1, 15, 0, 0]  # i = 5
fake =                              = [1, 7, 1, 3, 1, 15, 8, 0]  # i = 6
fake =                              = [1, 7, 1, 3, 1, 15, 8, 0]  # i = 7
```
In the next to last iteration with `i = 6`, we only had one value left to XOR in, and for the last where `i = 7`, the loop breaks without any change to `fake`. This will always be the case, so `fake` always has a 0 in the last position.

Let's take a look at how the `key` and `fake` values will be paired in `public`. For now, we ignore the order within each pair (so just assume `keystream = 00000000`) and the shuffle - we just look at each `key` value and the corresponding value that is created in `fake`:
```python
    ( key[0],  0 ^ key[1] ^ key[2] ),
    ( key[1],  0 ^ key[2] ^ key[3] ),
    ( key[2],  0 ^ key[3] ^ key[4] ),
    ( key[3],  0 ^ key[4] ^ key[5] ),
    ( key[4],  0 ^ key[5] ^ key[6] ),
    ( key[5],  0 ^ key[6] ^ key[7] ),
    ( key[6],  0 ^ key[7]          ),
    ( key[7],  0                   )
```
We see that we can work backwards from this. If we find a pair with a 0, then the other element is `key[7]`. And when we know `key[7]`, we can find another `fake` value, `0 ^ key[7]`, giving us `key[6]`. We then look for `key[6] ^ key[7]`, which gives us `key[5]`, etc.

So just from `public` we can guess each `key` from last to first, giving us the entire `key` at the end.

## Exploit

To exploit the vulnerability we found, we write the following script:
```python
key = []
k = 0
for i in range(ln):
    for a, b in pb:
        if a == k:
            key.append(b)
            break
        elif b == k:
            key.append(a)
            break
    k = xor_list(key[-ln // 3:])
```
Here, `k` is the current value from `fake` we are looking for, starting with `0`. The inner loop then goes through each pair of `public` and checks if one of the two values is `k`. If that is the case, then we know that value is from `fake`, so we add the other value of the pair to `key`. Then we update `k` to be the XOR of the last `ln // 3` values from `key`, since this is the next value from `fake` to look for -- as we saw when analyzing how `fake` was populated. The outer loop just repeats this once per `key` value, and when this is done, we have the entire `key`.

Having now both `key` and `public`, we can recover the `keystream` and decrypt the `flag`:
```python
keystream = recover_keystream(key, public)
flag = bits_to_bytes(xor(enc, keystream))
print(flag.decode())
```
We get the flag

    pbctf{super_duper_easy_brute_forcing_actually_this_one_was_made_by_mistake}

The full decryption script can be downloaded [here]({{ site.baseurl }}/assets/CTFs/2021/pbctf/decrypt.py).


## Notes

A few things to note: First, we recover the `key` in reverse order. This has no significance, since the recover function generates the `keystream` based on `public` -- `key` is only used as a set for lookups.

Secondly, in the decryption script, we make a copy of `public` and work on this. This allows us to delete each pair we have already used, which is necessary to avoid some duplicate value issues.